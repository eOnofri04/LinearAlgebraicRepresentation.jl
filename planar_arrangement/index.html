<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Planar arrangement · LinearAlgebraicRepresentation.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/lar.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LinearAlgebraicRepresentation.jl logo"/></a><h1>LinearAlgebraicRepresentation.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../lar/">L.A.R. Intro</a></li><li><a class="toctext" href="../interface/">Interface</a></li><li><span class="toctext">Arrangement</span><ul><li><a class="toctext" href="../arrangement/">Arrangement module</a></li><li class="current"><a class="toctext" href>Planar arrangement</a><ul class="internal"><li><a class="toctext" href="#The-Arrangement-Algorithm-1">The Arrangement Algorithm</a></li><li><a class="toctext" href="#Examples-1">Examples</a></li></ul></li></ul></li><li><span class="toctext">Parametric primitives</span><ul><li><a class="toctext" href="../mapper/">Mapper</a></li><li><a class="toctext" href="../struct/">Assemblies</a></li></ul></li><li><span class="toctext">Grid generation</span><ul><li><a class="toctext" href="../largrid/">Cuboidal grids</a></li><li><a class="toctext" href="../simplexn/">Simplicial grids</a></li></ul></li><li><a class="toctext" href="../integr/">Domain integration</a></li></ul></nav><article id="docs"><header><nav><ul><li>Arrangement</li><li><a href>Planar arrangement</a></li></ul><a class="edit-page" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/master/docs/src/planar_arrangement.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Planar arrangement</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Arrangement-of-cellular-complexes-in-two-dimensional-spaces-1" href="#Arrangement-of-cellular-complexes-in-two-dimensional-spaces-1">Arrangement of cellular complexes in two-dimensional spaces</a></h1><p>The module Arangement provides two dimensional space arrangements via the following method (accesible from the <code>LinearAlgebraicRepresentation</code> namespace):</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.planar_arrangement" href="#LinearAlgebraicRepresentation.planar_arrangement"><code>LinearAlgebraicRepresentation.planar_arrangement</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">planar_arrangement(V::Points, copEV::ChainOp
	[, sigma::Chain[, return_edge_map::Bool[, multiproc::Bool]]]
)</code></pre><p>Compute the arrangement on the given cellular complex 1-skeleton in 2D. Whole arrangement&#39;s algorithmic pipeline. </p><p>A cellular complex is arranged when the intersection of every possible pair of cell  of the complex is empty and the union of all the cells is the whole Euclidean space. The method with no additional arguments specified gives back the full arranged complex <code>V</code>, <code>EV</code> and <code>FE</code>.</p><p>See also:</p><ul><li><a href="#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_1"><code>Lar.Arrangement.planar_arrangement_1</code></a></li><li><a href="#LinearAlgebraicRepresentation.Arrangement.biconnected_components"><code>Lar.Arrangement.biconnected_components</code></a></li><li><a href="#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_2"><code>Lar.Arrangement.planar_arrangement_2</code></a></li></ul><p><strong>Additional arguments:</strong></p><ul><li><code>sigma::Chain</code>: if specified, <code>planar_arrangement</code> will delete from the output every edge and face outside this cell. Defaults to an empty cell.</li><li><code>return_edge_map::Bool</code>: makes the function return also an <code>edge_map</code> which maps the edges of the imput to the one of the output. Defaults to <code>false</code>.</li><li><code>multiproc::Bool</code>: Runs the computation in parallel mode. Defaults to <code>false</code>.</li></ul><p>Many examples could be found in Lar Documentation and <code>examples</code> directory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L1151-L1177">source</a></section><p>In general we recall the notation we have used in source code:</p><ul><li><code>V::Lar.Points</code> is the 1-cells (Vertices) complex by Columns.</li><li><code>W::Lar.Points</code> is the 1-cells (Vertices) complex by Rows.</li><li><code>EV::Lar.Cells</code> is the 2-cells (Edges) complex.</li><li><code>FV::Lar.Cells</code> is the 3-cells (Faces) complex.</li><li><code>copEV::Lar.ChainOp</code>: is the Chain Coboundary of the 2-cells.</li><li><code>copFE::Lar.ChainOp</code>: is the Chain Coboundary of the 3-cells.</li><li><code>bigPI::Array{Array{Int64,1},1}</code>: is the bounding box intersection array:</li></ul><p>each row is associated to a 2-cell and contains the indices of the other 2-cells intersecting its bounding box.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Do remember that in <code>planar_arrangement</code> (<code>Lar.Arrangement</code> module) matrices store points per row and not per column as described in the documentation of <code>Lar.Points</code>.</p></div></div><h2><a class="nav-anchor" id="The-Arrangement-Algorithm-1" href="#The-Arrangement-Algorithm-1">The Arrangement Algorithm</a></h2><p>In this section we will provide a general overview of how the <code>planar_arrangement</code> is meant to work.</p><p>The algorithm is divided into the following pipeline:</p><ul><li>Fragmentation of the 2-Cells.<ul><li>Spatial Indexing.</li><li>Pairwise 2-Cells Fragmentation.</li><li>Vertices Identification.</li></ul></li><li>Biconnected Components Detection.</li><li>3-Cells Evaluation and Dangling 2-Cells Elimination via Topological Gift Wrapping (TGW) algorithm.<ul><li>Component graph evaluation (TGW offline part).<ul><li>Evalution of the external cicle.</li><li>Containment graph evaluation.</li><li>Pruning of the containment graph.</li><li>Transitive <span>$R$</span> reduction of <span>$S$</span> and generation of forest of flat trees</li></ul></li><li>Decomposition Cleaning (if a boundary has been specified).</li><li>Shell poset aggregation (TGW onloine part).</li></ul></li></ul><h3><a class="nav-anchor" id="Fragmentation-of-the-2-Cells-1" href="#Fragmentation-of-the-2-Cells-1">Fragmentation of the 2-Cells</a></h3><p>This part of the pipeline is covered by:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.planar_arrangement_1" href="#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_1"><code>LinearAlgebraicRepresentation.Arrangement.planar_arrangement_1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function planar_arrangement_1(V, copEV[, sigma[, return_edge_map[, multiproc]]])</code></pre><p>First part of arrangement&#39;s algorithmic pipeline.</p><p>This function computes the pairwise intersection between each edge of a given 2D cellular complex 1-skeleton. The computation is speeded up via the evaluation of the Spatial Index. See <a href="#LinearAlgebraicRepresentation.spaceindex"><code>Lar.spaceindex</code></a>. </p><p>See also: <a href="#LinearAlgebraicRepresentation.planar_arrangement"><code>Lar.planar_arrangement</code></a> for the complete pipeline.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; EV = [[1, 2], [3, 4], [1, 3], [2, 4], [5, 6], [7, 8], [5, 7], [6, 8]];

julia&gt; V = [
           0.0 0.5 0.0 0.5 0.3 1.0 0.3 1.0;
           0.0 0.0 1.0 1.0 0.5 0.5 1.0 1.0
       ];

julia&gt; W = convert(Lar.Points, V&#39;); # Infering type for W = V&#39;

julia&gt; cop_EV = Lar.coboundary_0(EV::Lar.Cells);

julia&gt; W1, copEV1 = Lar.planar_arrangement_1(W::Lar.Points, cop_EV::Lar.ChainOp)
([0.0 0.0; 0.5 0.0; … ; 1.0 0.5; 1.0 1.0], 
  [1 ,  1]  =  1
  [4 ,  1]  =  1
  [1 ,  2]  =  1
  ⋮
  [11,  8]  =  1
  [9 ,  9]  =  1
  [11,  9]  =  1)

julia&gt; EV1 = Lar.cop2lar(copEV1);

julia&gt; V1 = convert(Lar.Points, W1&#39;);

julia&gt; Plasm.view(Plasm.numbering(0.1)((V,[[[k] for k=1:size(V,2)], EV])));

julia&gt; Plasm.view(Plasm.numbering(0.1)((V1,[[[k] for k=1:size(V1,2)], EV1])));</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L971-L1014">source</a></section><p>A small set of optional parameters could be choosen in order to personalize the computation:</p><ul><li><code>sigma::Lar.Chain</code>: if specified, the arrangement will delete from the output every edge outside this cell                      (<em>by defaults</em> = empty cell, no boundary).</li><li><code>return_edge_map::Bool</code>: If set to true, the function will also return an <code>edge_map</code> that maps the input edges to                      the corresponding output ones.</li><li><code>multiproc::Bool</code>: If set to true, execute the arrangement in parallel (<em>by default</em> = false, sequential).</li></ul><p>Once the data have been aquired, a spatial indexing between the 2-cells is made up in order to speed up the computation.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.spaceindex" href="#LinearAlgebraicRepresentation.spaceindex"><code>LinearAlgebraicRepresentation.spaceindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">spaceindex(model::Lar.LAR)::Array{Array{Int,1},1}</code></pre><p>Generation of <em>space indexes</em> for all <span>$(d-1)$</span>-dim cell members of <code>model</code>.</p><p><em>Spatial index</em> made by <span>$d$</span> <em>interval-trees</em> on  bounding boxes of <span>$σ ∈ S_{d−1}$</span>. Spatial queries solved by intersection of <span>$d$</span> queries on IntervalTrees generated by bounding-boxes of geometric objects (LAR cells).</p><p>The return value is an array of arrays of <code>int</code>s, indexing cells whose  containment boxes are intersecting the containment box of the first cell.  According to Hoffmann, Hopcroft, and Karasick (1989) the worst-case complexity of Boolean ops on such complexes equates the total sum of such numbers. </p><p><strong>Examples 2D</strong></p><pre><code class="language-none">julia&gt; V = hcat([[0.,0],[1,0],[1,1],[0,1],[2,1]]...);

julia&gt; EV = [[1,2],[2,3],[3,4],[4,1],[1,5]];

julia&gt; Sigma = Lar.spaceindex((V,EV))
5-element Array{Array{Int64,1},1}:
 [4, 5, 2]   
 [1, 3, 5]   
 [4, 5, 2]   
 [1, 3, 5]   
 [4, 1, 3, 2]</code></pre><p>From <code>model2d</code> value, available in <code>?input_collection</code> docstring:</p><pre><code class="language-julia">julia&gt; Sigma =  spaceindex(model2d);</code></pre><p><strong>Example 3D</strong></p><pre><code class="language-julia">model = model3d
Sigma =  spaceindex(model3d);
Sigma</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/refactoring.jl#L235-L279">source</a></section><p>Then each single 2-cell is fragmented by intersecting it with the other 2-cells that shares the same bounding box. This process is either done in a parralel or a sequtial way via:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.frag_edge_channel" href="#LinearAlgebraicRepresentation.Arrangement.frag_edge_channel"><code>LinearAlgebraicRepresentation.Arrangement.frag_edge_channel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">frag_edge_channel(in_chan, out_chan, V, EV, bigPI)</code></pre><p>Utility function for parallel edge fragmentation.</p><p>This function handles the edge fragmentation in the first part of arrangement&#39;s algorithmic pipeline (see also <a href="#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_1"><code>Lar.Arrangement.planar_arrangement_1</code></a>) during multiprocessing computation. In order to do so it needs two <code>Distributed.RemoteChannel</code>s, one with the inputs and one for outputs.</p><p>See also: <a href="#LinearAlgebraicRepresentation.Arrangement.frag_edge"><code>Lar.Arrangement.frag_edge</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L10-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.frag_edge" href="#LinearAlgebraicRepresentation.Arrangement.frag_edge"><code>LinearAlgebraicRepresentation.Arrangement.frag_edge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">frag_edge(V, EV, edge_idx, bigPI)</code></pre><p>Splits the <code>edge_idx</code>-th edge in <code>EV</code>.</p><p>This method splits the <code>edge_idx</code>-th edge in <code>EV</code> into several parts by confronting it with the others that intersect its bounding box (see also <a href="#LinearAlgebraicRepresentation.Arrangement.intersect_edges"><code>Lar.Arrangement.intersect_edges</code></a>).</p><p>The method returns a set of the new vertices that the segment is made of (with redundancies) and the associated cochain (with no redundancies).</p><p>See also:</p><ul><li><a href="#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_1"><code>Lar.Arrangement.planar_arrangement_1</code></a></li><li><a href="#LinearAlgebraicRepresentation.Arrangement.frag_edge_channel"><code>Lar.Arrangement.frag_edge_channel</code></a></li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; V = [1.0 0.0; 0.0 1.0; 0.0 0.5; 0.5 1.0; 1.0 1.0]; # By Rows!

julia&gt; EV = [[1, 2], [2, 5], [3, 4], [4, 5]];

julia&gt; copEV = Lar.coboundary_0(EV::Lar.Cells);

julia&gt; bigPI = Lar.spaceindex((convert(Lar.Points, V&#39;), EV));

julia&gt; Lara.frag_edge(V, copEV, 1, bigPI)[1]
5×2 Array{Float64,2}:
 1.0   0.0 
 0.0   1.0 
 1.0   0.0 
 0.25  0.75
 0.0   1.0 

julia&gt; Lara.frag_edge(V, copEV, 1, bigPI)[2]
2×5 SparseMatrixCSC{Int8,Int64} with 4 stored entries:
  [1, 1]  =  1
  [2, 2]  =  1
  [1, 4]  =  1
  [2, 4]  =  1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L38-L80">source</a></section><p>if the parallel way is choosen (namely <code>frag_edge_channel</code> is used) then a few more parameters must be specified:</p><ul><li><code>in_chan::Distributed.RemoteChannel{Channel{Int64}}</code>: an input channel made of the edges indices to be intersected;      the channel must also hold at the end an EoW (<code>-1</code>) indicator for each worker thread in use.</li><li><code>out_chan::Distributed.RemoteChannel{Channel{Int64}}</code>: a ready-to-use output channel.</li></ul><p>In order to split the edge, at a lower level, each pair of possible intersecting 2-cells are compared via:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.intersect_edges" href="#LinearAlgebraicRepresentation.Arrangement.intersect_edges"><code>LinearAlgebraicRepresentation.Arrangement.intersect_edges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">intersect_edges(V, edge1, edge2)</code></pre><p>Finds the intersection point (if there exists) between the two given edges.</p><p>This method compute the points where <code>edge2</code> intersect <code>edge1</code>. If they are collinear only the vertices of <code>edge2</code> are considered (see the second example).</p><p>See also: <a href="#LinearAlgebraicRepresentation.Arrangement.frag_edge"><code>Lar.Arrangement.frag_edge</code></a></p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia-repl"># Cross
julia&gt; V = [1.0 0.0; 0.0 1.0; 0.0 0.5; 0.5 1.0]; # By Rows!

julia&gt; EV = [[1, 2], [3, 4]];

julia&gt; copEV = Lar.coboundary_0(EV::Lar.Cells);

julia&gt; Lara.intersect_edges(V, copEV[1, :], copEV[2, :])
1-element Array{Tuple{Array{T,2} where T,Float64},1}:
 ([0.25 0.75], 0.75)</code></pre><pre><code class="language-julia-repl"># Collinear
julia&gt; V = [1.0 0.0; 0.0 1.0; 0.75 0.25; 0.5 0.5]; # By Rows!

julia&gt; EV = [[1, 2], [3, 4]];

julia&gt; copEV = Lar.coboundary_0(EV::Lar.Cells);

julia&gt; Lar.Arrangement.intersect_edges(V, copEV[1, :], copEV[2, :])
2-element Array{Tuple{Array{T,2} where T,Float64},1}:
 ([0.75 0.25], 0.25)
 ([0.5 0.5], 0.5) 

julia&gt; Lar.Arrangement.intersect_edges(V, copEV[2, :], copEV[1, :])
0-element Array{Tuple{Array{T,2} where T,Float64},1}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L107-L149">source</a></section><p>In the end, the 1-cells are identified if they are located spatially very close one to the other (<em>i.e</em> <span>$\epsilon = 10^{-4}$</span>). Of course if two 2-cells share the same endpoints then they are also identified in a unique 2-cell.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.merge_vertices!" href="#LinearAlgebraicRepresentation.Arrangement.merge_vertices!"><code>LinearAlgebraicRepresentation.Arrangement.merge_vertices!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">merge_vertices!(V, EV[, edge_map[, err]])</code></pre><p>Compact the vertices closer than <code>err</code> in a single one.</p><p>This method check one at time each vertex <span>$v$</span> in <code>V</code> and identifies each other vertex within <code>err</code> with <span>$v$</span> itself. The cochain <code>EV</code> is coherently modified (multiple edges between two vertices are not allowed). If an <code>edge_map</code> is given in input (this could be usefull during the planar arrangements), then also the map is coherently modified and given back in output.</p><p>See also: <a href="#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_1"><code>Lar.Arrangement.planar_arrangement_1</code></a></p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia-repl"># Collinear
julia&gt; V = [0.5 0.5; 0.0 0.0; 0.5 0.5; 1.0 1.0; 0.5 0.5; 1.0 1.0]; # By Rows!

julia&gt; EV = [[1, 4], [3, 2], [5, 6], [1, 6], [5, 3]];

julia&gt; copEV = Lar.coboundary_0(EV::Lar.Cells);

julia&gt; Lara.merge_vertices!(V, copEV)[1]
3×2 Array{Float64,2}:
 0.5  0.5
 0.0  0.0
 1.0  1.0

julia&gt; Lara.merge_vertices!(V, copEV)[2]
2×3 SparseArrays.SparseMatrixCSC{Int8,Int64} with 4 stored entries:
  [1, 1]  =  1
  [2, 1]  =  1
  [2, 2]  =  1
  [1, 3]  =  1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L195-L231">source</a></section><p>Here also two optional parameters could be specified:</p><ul><li><code>edge_map::Array{Array{Int64,1},1}</code>: Mapping from a set of edges to the edges of the given cochain.      If it is given in input than a copy of it would be returned in output, with its values coherently rearranged with the vertices merging (<em>by default</em> = <span>$[[-1]]$</span>).</li><li><code>err::Float64</code>: Range of the vertex identification (<em>by default</em> = <span>$1e-4$</span>).</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Choosing a good value for <code>err</code> is a very important issue. Note that the identification is sequentially made; therefore the following situation could happend: if three vertices are collinear and evenly spaciated, then</p><ul><li>if the second is identified in the third,</li></ul><p>then the first and the third won&#39;t be identified;</p><ul><li>if the third is identified with the second,</li></ul><p>then the first and the second will be identified;</p><p>This situation could be seen in the secon example given by the function documentation.</p></div></div><h3><a class="nav-anchor" id="Biconnected-Components-Detection.-1" href="#Biconnected-Components-Detection.-1">Biconnected Components Detection.</a></h3><p>This part of the pipeline is covered by</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.biconnected_components" href="#LinearAlgebraicRepresentation.Arrangement.biconnected_components"><code>LinearAlgebraicRepresentation.Arrangement.biconnected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">biconnected_components(EV)</code></pre><p>Compute sets of 2-cells on the same 3-cells biconnected components.</p><p>The method evaluate the 2-cells <span>$σ_i$</span> wich lies on the same 3-cells biconnected component <span>$χ_j$</span> and gives back an array that contains an array of <span>$σ_i$</span> for each <span>$j$</span>. Do note that if the cochain EV contains more copies of the same 2-cell then it will be considered like a 3-cell.</p><p>Intermediate part of Planar Arrangement&#39;s algorithmic pipeline.</p><p>See also: <a href="#LinearAlgebraicRepresentation.planar_arrangement"><code>Lar.planar_arrangement</code></a> for the complete pipeline.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; copEV = SparseArrays.sparse(Array{Int8, 2}([
    [1 1 0 0 0 0] #1 -&gt; 1,2  |
    [1 0 1 0 0 0] #2 -&gt; 1,3  |
    [1 0 0 1 0 0] #3 -&gt; 1,4   |
    [1 0 0 0 1 0] #4 -&gt; 1,5   |
    [1 0 0 0 0 1] #5 -&gt; 1,6
    [0 1 1 0 0 0] #6 -&gt; 2,3  |
    [0 0 0 1 1 0] #7 -&gt; 4,5   |
    ]));
julia&gt; Lara.biconnected_components(copEV)
2-element Array{Array{Int64,1},1}:
 [2, 6, 1]
 [4, 7, 3]</code></pre><pre><code class="language-julia-repl">julia&gt; copEV = SparseArrays.sparse(Array{Int8, 2}([
    [1 1 0] #1 -&gt; 1,2  |
    [1 1 0] #2 -&gt; 1,2  |
    [1 0 1] #3 -&gt; 1,2
    ]));
julia&gt; Lara.biconnected_components(copEV)
1-element Array{Array{Int64,1},1}:
 [2, 1]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L302-L345">source</a></section><p>As a reader can see the components are evaluated regardless the model geometrical structure; in fact the 1-cells are not considered during the computation. This means that the abstract graph made by the edges is the only input needed by the function.</p><h3><a class="nav-anchor" id="Cells-Evaluation-and-Dangling-2-Cells-Elimination.-1" href="#Cells-Evaluation-and-Dangling-2-Cells-Elimination.-1">3-Cells Evaluation and Dangling 2-Cells Elimination.</a></h3><p>This part of the pipeline is covered by</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.planar_arrangement_2" href="#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_2"><code>LinearAlgebraicRepresentation.Arrangement.planar_arrangement_2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function planar_arrangement_2(V, copEV, bicon_comps
	[, sigma[, return_edge_map[, multiproc]]]
)</code></pre><p>Second part of arrangement&#39;s algorithmic pipeline.</p><p>This function is the complete Topological Gift Wrapping (TGW) algorithm that is firstly locally used in order to decompose the 2-cells and then globally to generate the 3-cells of the arrangement of the ambient space <span>$E^3$</span>.</p><p>During this process each dangling 2-cell is removed. Do note that the isolated 1-cells are not removed by this procedure.</p><p>See also: <a href="#LinearAlgebraicRepresentation.planar_arrangement"><code>Lar.planar_arrangement</code></a> for the complete pipeline.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia-repl"># Triforce
julia&gt; V = [0.0 0.0; 2.0 0.0; 4.0 0.0; 1.0 1.5; 3.0 1.5; 2.0 3.0; 3.0 3.0];
julia&gt; W = convert(Lar.Points, V&#39;);
julia&gt; EV = SparseArrays.sparse(Array{Int8, 2}([
    [1 1 0 0 0 0 0] #1 -&gt; 1,2
    [0 1 1 0 0 0 0] #2 -&gt; 2,3
    [1 0 0 1 0 0 0] #3 -&gt; 1,4
    [0 0 0 1 0 1 0] #4 -&gt; 4,6
    [0 0 1 0 1 0 0] #5 -&gt; 3,5
    [0 0 0 0 1 1 0] #6 -&gt; 5,6
    [0 1 0 1 0 0 0] #7 -&gt; 2,4
    [0 1 0 0 1 0 0] #8 -&gt; 2,5
    [0 0 0 1 1 0 0] #9 -&gt; 4,5
    [0 0 0 0 0 1 1]
    ]));

julia&gt; Plasm.view(Plasm.numbering(0.5)(
		(W,[[[k] for k=1:size(W,2)], Lar.cop2lar(EV)])
	));

julia&gt; bicon_comps = Lar.Arrangement.biconnected_components(EV);

julia&gt; V, EV, FE = Lar.Arrangement.planar_arrangement_2(V, EV, bicon_comps);

julia&gt; Plasm.view( Plasm.numbering1(0.5)((V, EV, FE)) );</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L1080-L1126">source</a></section><p>First of all the components of the graph are evaluated via</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.componentgraph" href="#LinearAlgebraicRepresentation.Arrangement.componentgraph"><code>LinearAlgebraicRepresentation.Arrangement.componentgraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">componentgraph(V, copEV, bicon_comps)</code></pre><p>Topological Gift Wrapping algorithm on 2D skeletons.</p><p>This is the offline part of the TGW algorithm. It takes in input a model and its biconnected components mapping and evaluates usefull informations:</p><ol><li>Number of biconnected components.</li><li>Component Graph of the biconnected structure.</li><li>The 1-cells structure (UNMODIFIED). &lt;––––––––––––––- Could be removed?</li><li>Association between non-dangling 2-cells and their orientation (for each component).</li><li>Association between 3-cells and 2-cells (with orientation, for each component).</li><li>Association between 3-cells and their orientation (for each component).</li><li>Shell bounding boxes of the components.</li></ol><p>See also: <a href="#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_2"><code>Lar.Arrangement.planar_arrangement_2</code></a> for the TGW.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia-repl"># Papillon
julia&gt; V = [0.0 0.0; 0.0 3.0; 2.0 1.5; 4.0 0.0; 4.0 3.0];

julia&gt; copEV = SparseArrays.sparse(Array{Int8, 2}([
		[1 1 0 0 0] #1 -&gt; 1,2
		[0 1 1 0 0] #2 -&gt; 2,3
		[1 0 1 0 0] #3 -&gt; 3,1
		[0 0 1 1 0] #4 -&gt; 3,4
		[0 0 0 1 1] #5 -&gt; 4,5
		[0 0 1 0 1] #6 -&gt; 3,5
	]));

julia&gt; copFE = SparseArrays.sparse(Array{Int8, 2}([
		[1 1 1 0 0 0] #1 -&gt; 1,2,3
		[0 0 0 1 1 1] #2 -&gt; 4,5,6
		[1 1 1 1 1 1] #3 -&gt; 1,2,3,4,5,6 External
	]));

julia&gt; bicon_comps = [[1, 2, 3], [4, 5, 6]];

julia&gt; Lara.componentgraph(V, copEV, bicon_comps)[1]
2

julia&gt; Lara.componentgraph(V, copEV, bicon_comps)[2]
2×2 SparseMatrixCSC{Int8,Int64} with 0 stored entries

julia&gt; Lara.componentgraph(V, copEV, bicon_comps)[4]
2-element Array{SparseMatrixCSC{Int8,Int64},1}:
 
  [1, 1]  =  -1
  [3, 1]  =  -1
  [1, 2]  =  1
  [2, 2]  =  -1
  [2, 3]  =  1
  [3, 3]  =  1
 
  [1, 3]  =  -1
  [3, 3]  =  -1
  [1, 4]  =  1
  [2, 4]  =  -1
  [2, 5]  =  1
  [3, 5]  =  1

julia&gt; Lara.componentgraph(V, copEV, bicon_comps)[5]
2-element Array{SparseMatrixCSC{Int8,Int64},1}:
 
  [1, 1]  =  -1
  [1, 2]  =  -1
  [1, 3]  =  1
 
  [1, 1]  =  1
  [1, 2]  =  1
  [1, 3]  =  -1 

julia&gt; Lara.componentgraph(V, copEV, bicon_comps)[6]
2-element Array{SparseVector{Int8,Int64},1}:
   [1]  =  1
  [2]  =  1
  [3]  =  -1 
   [1]  =  -1
  [2]  =  -1
  [3]  =  1

julia&gt; Lara.componentgraph(V, copEV, bicon_comps)[7]
2-element Array{Any,1}:
 ([0.0 0.0], [2.0 3.0])
 ([2.0 0.0], [4.0 3.0])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L727-L817">source</a></section><p>Then, if a special chain <span>$\sigma$</span> has been specified, the given decomposition is cleaned from all the 2-cells (and consequently from alle the 1-cells) that are located ouside its boundary via</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.cleandecomposition" href="#LinearAlgebraicRepresentation.Arrangement.cleandecomposition"><code>LinearAlgebraicRepresentation.Arrangement.cleandecomposition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cleandecomposition(V, copEV, sigma)</code></pre><p>!!! NOT WORKING</p><p>This function clears the model <code>(V, copEV)</code> from all edges outside <span>$σ$</span>.</p><p>This function takes a model <code>(V, copEV)</code> and a <code>Lar.Chain</code> <span>$σ$</span> and gives back the dropped model and and a vector <code>todel</code> of the 2-cells to drop.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia-repl"># Nested Triangles
julia&gt; V = [
		0.0 0.0; 2.0 0.0; 4.0 0.0;
		1.0 1.5; 3.0 1.5; 2.0 3.0;
		2.0 -3.; -2. 3.0; 6.0 3.0
	];

julia&gt; copEV = SparseArrays.sparse(Array{Int8, 2}([
    [1 0 1 0 0 0 0 0 0] #1 -&gt; 1,3
    [1 0 0 0 0 1 0 0 0] #2 -&gt; 1,6
    [0 0 1 0 0 1 0 0 0] #3 -&gt; 3,6
    [0 1 0 1 0 0 0 0 0] #4 -&gt; 2,4
    [0 1 0 0 1 0 0 0 0] #5 -&gt; 2,5
    [0 0 0 1 1 0 0 0 0] #6 -&gt; 4,5
    [0 0 0 0 0 0 1 1 0] #7 -&gt; 7,8
    [0 0 0 0 0 0 1 0 1] #8 -&gt; 7,9
    [0 0 0 0 0 0 0 1 1] #9 -&gt; 8,9
    ]));

julia&gt; σ = SparseArrays.sparse([0; 0; 0; 1; 1; 1; 0; 0; 0]);

todel, V, copEV = Lara.cleandecomposition(V, copEV, convert(Lar.Chain, σ))

Plasm.view(convert(Lar.Points, V&#39;), Lar.cop2lar(copEV));</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L864-L903">source</a></section><p>Lastly the 2-cells are merged in order to retrieve the 3-cell of the complex. By doing so, all the 2-cells that are not linked to any 3-cell (<em>i.e.</em> dangling edges) are lost.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Do note that the 1-cells are not pruned during this computation. Therefore the vertices associated with dangling edges will still be there.</p></div></div><p>This last part of the computation is done via:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.cell_merging" href="#LinearAlgebraicRepresentation.Arrangement.cell_merging"><code>LinearAlgebraicRepresentation.Arrangement.cell_merging</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cell_merging(n, containment_graph, V, EVs, boundaries, shells, shell_bboxes)</code></pre><p>Cells composing for the Topological Gift Wrapping algorithm.</p><p>This is the online part of the TGW algorithm.</p><p>See also: <a href="#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_2"><code>Lar.Arrangement.planar_arrangement_2</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L662-L670">source</a></section><h4><a class="nav-anchor" id="Component-graph-evaluation-1" href="#Component-graph-evaluation-1">Component graph evaluation</a></h4><p>Component Graph evaluation relies on different functions that could be use separatelly in order to obtain different results.</p><p>First of all we use the following function on each biconnected component in order to gain the faces of the complex:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.get_external_cycle" href="#LinearAlgebraicRepresentation.Arrangement.get_external_cycle"><code>LinearAlgebraicRepresentation.Arrangement.get_external_cycle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">get_external_cycle(V, EV, FE)</code></pre><p>Evaluates the index of the external 3D-cell.</p><p>This method looks for and retrieve the external cycle of the model <code>(V, EV, FE)</code>. If the cell does not exist then it return a <code>Nothing</code> element.</p><p>See also: <a href="#LinearAlgebraicRepresentation.Arrangement.componentgraph"><code>Lar.Arrangement.componentgraph</code></a>.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia-repl"># ``K^4`` graph
julia&gt; V = [0.0 0.0; 4.0 0.0; 2.0 3.0; 2.0 1.5];
julia&gt; copEV = SparseArrays.sparse(Array{Int8, 2}([
		[1 1 0 0] #1 -&gt; 1,2
		[0 1 1 0] #2 -&gt; 2,3
		[1 0 1 0] #3 -&gt; 3,1
		[1 0 0 1] #4 -&gt; 1,2
		[0 1 0 1] #5 -&gt; 2,3
		[0 0 1 1] #6 -&gt; 3,1
	]));
julia&gt; copFE = SparseArrays.sparse(Array{Int8, 2}([
		[1 0 0 1 1 0] #1 -&gt; 1,4,5
		[0 1 0 0 1 1] #2 -&gt; 2,5,6
		[0 0 1 1 0 1] #3 -&gt; 3,4,6
		[1 1 1 0 0 0] #4 -&gt; 1,2,3 External
	]));

julia&gt; Lara.get_external_cycle(V, copEV, copFE)
4

julia&gt; typeof(Lara.get_external_cycle(V, copEV, copFE[1:3,:]))
Nothing</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L448-L485">source</a></section><p>Then a containment graph is build in order to clarify if some biconnected component relies in another biconnected component. To do so, the approach is similiar to what we did with the 2-cells decomposition. We firstly build the bounding box of each component and we check whether they are one inside the other via:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.pre_containment_test" href="#LinearAlgebraicRepresentation.Arrangement.pre_containment_test"><code>LinearAlgebraicRepresentation.Arrangement.pre_containment_test</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pre_containment_test(bboxes)</code></pre><p>Generate the containment graph associated to <code>bboxes</code>.</p><p>The function evaluate a <code>SparseArrays{Int8, n, n}</code> PRE-containmnet graph in the sense that it stores <code>1</code> when the bbox associated to the <code>i</code>-th component contains entirely the bbox associated to the <code>j</code>-th one. (where <code>n = length(bboxes)</code>)</p><p>See also:</p><ul><li><a href="#LinearAlgebraicRepresentation.Arrangement.componentgraph"><code>Lar.Arrangement.componentgraph</code></a>.</li><li><a href="../#LinearAlgebraicRepresentation.bbox_contains"><code>Lar.bbox_contains</code></a>.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia-repl"># Planar Tiles
julia&gt; bboxes = [
		([0.0 0.0], [1.0 1.0])
		([0.0 0.0], [0.4 0.4])
		([0.6 0.0], [1.0 0.4])
		([0.0 0.6], [0.4 1.0])
		([0.6 0.6], [1.0 1.0])
		([2.0 3.0], [2.0 3.0]) # no intersection
	];

julia&gt; Lara.pre_containment_test(bboxes)
5×5 SparseMatrixCSC{Int8,Int64} with 4 stored entries:
  [2, 1]  =  1
  [3, 1]  =  1
  [4, 1]  =  1
  [5, 1]  =  1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L520-L554">source</a></section><p>Then we prune the resulting mapping using:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.prune_containment_graph" href="#LinearAlgebraicRepresentation.Arrangement.prune_containment_graph"><code>LinearAlgebraicRepresentation.Arrangement.prune_containment_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">prune_containment_graph(n, V, EVs, shells, graph)</code></pre><p>Prunes the containment <code>graph</code> from the non-included faces.</p><p>This method prunes the containment graph eliminating the included bouning boxes that not corresponds to included faces.</p><p>Do note that this method expects to work on biconnectet clusters of faces.</p><p>See also:</p><ul><li><a href="#LinearAlgebraicRepresentation.Arrangement.componentgraph"><code>Lar.Arrangement.componentgraph</code></a>.</li><li><a href="@ref"><code>Lar.point_in_face</code></a>.</li></ul><p>```</p></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L571-L585">source</a></section><p>In order to do so we take each biconnected component <span>$\phi$</span> whose bounding box is inside the bounding box of <span>$\psi$</span> (<span>$\forall \psi$</span>) and we check if a point of <span>$phi$</span> is or is not on the possible <span>$\psi$</span> 3-cells. Do note that it is sufficient checking one single point since we know in advance that each couple of biconnected components is intersection free. Therefore if a single point of <span>$\phi$</span> is inside a biconnected component <span>$\psi$</span> then <span>$\phi \subset \psi$</span>.</p><p>However if three or more faces are nested one into the other, then the mapping is redundant. We therefore eliminate this redundany by applying:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.transitive_reduction!" href="#LinearAlgebraicRepresentation.Arrangement.transitive_reduction!"><code>LinearAlgebraicRepresentation.Arrangement.transitive_reduction!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">transitive_reduction!(graph)</code></pre><p>Prune the redundancies in containment <code>graph</code>.</p><p>The <span>$m$</span>-layer containment <code>graph</code> is reduced to the 1-layer containment <code>graph</code> where only the first level nested components are considered.</p><p>See also: <a href="#LinearAlgebraicRepresentation.Arrangement.componentgraph"><code>Lar.Arrangement.componentgraph</code></a>.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; containment = [
		0 0 0 0 0 0
		0 0 0 0 0 0
		1 0 0 0 0 0
		1 0 0 0 0 0
		1 0 1 0 0 0
		1 0 1 0 1 0
	];

julia&gt; transitive_reduction!(containment)

julia&gt; containment
6×6 Array{Int64,2}:
 0  0  0  0  0  0
 0  0  0  0  0  0
 1  0  0  0  0  0
 1  0  0  0  0  0
 0  0  1  0  0  0
 0  0  0  0  1  0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/eOnofri04/LinearAlgebraicRepresentation.jl/blob/b8a3e053afeae5664cba01c93f91f6ad6bfe01bc/src/arrangement/planar_arrangement.jl#L611-L645">source</a></section><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><p>Lastly we close this section by giving a small example of how Planar Arrangement Works. Using <code>Plasm</code> we are able to visualize the step of the computation grafically.</p><pre><code class="language-julia">using Plasm
using LinearAlgebraicRepresentation
Lar = LinearAlgebraicRepresentation;

# Data Reading
V = [
	0.0 0.5 3.0 5.0 2.0 2.0 0.0 1.0 0.0 3.0; 
	1.0 1.0 1.0 1.0 2.0 0.0 3.0 1.5 0.0 1.5
	];
EV = [[1, 4], [2, 3], [5, 6], [2, 5], [3, 6], [7, 10], [8, 10], [9, 10]];

## 1 - Input Reading
Plasm.view(Plasm.numbering(0.5)((V,[[[k] for k=1:size(V,2)], EV])));

# Planar Arrangement 1
W = convert(Lar.Points, V&#39;); # Infering type for W = V&#39;
copEV = Lar.coboundary_0(EV::Lar.Cells);
W1, copEV1 = Lar.planar_arrangement_1(W::Lar.Points, copEV::Lar.ChainOp);

## 2 - 2-cells fragmentation
EV1 = Lar.cop2lar(copEV1);
V1 = convert(Lar.Points, W1&#39;);
Plasm.view(Plasm.numbering(0.5)((V1,[[[k] for k=1:size(V1,2)], EV1])));

# Biconnected COmponent Evaluation
bicon_comps = Lar.Arrangement.biconnected_components(copEV1);

## 3 - Biconnected Components
hpcs = [ Plasm.lar2hpc(V1,[EV1[e] for e in comp]) for comp in bicon_comps ]
Plasm.view([
	Plasm.color(Plasm.colorkey[(k%12)==0 ? 12 : k%12])(hpcs[k])
	for k = 1 : (length(hpcs))
])

# computation of 2-cells and 2-boundary
W2, copEV2, copFE2 = Lar.planar_arrangement_2(W1, copEV1, bicon_comps)

## 4 - 3-cells identification &amp; dangling 1-cells elimination
Plasm.view( Plasm.numbering1(0.5)((W2, copEV2, copFE2)) )


# 5 - Colorfull Representation
triangulated_faces = Lar.triangulate2D(W2, [copEV2, copFE2])
V2 = convert(Lar.Points, W2&#39;)
FVs2 = convert(Array{Lar.Cells}, triangulated_faces)
Plasm.viewcolor(V2::Lar.Points, FVs2::Array{Lar.Cells})

# polygonal face boundaries
EVs2 = Lar.FV2EVs(copEV2, copFE2) 
EVs2 = convert(Array{Array{Array{Int64,1},1},1}, EVs2)
Plasm.viewcolor(V2::Lar.Points, EVs2::Array{Lar.Cells})

# 6 - Exploded Representation
model = V2,EVs2
Plasm.view(Plasm.lar_exploded(model)(1.2,1.2,1.2))</code></pre><p>The described commands gives the following representation via Plasm. Here we have reunited all the images in order to clarify the example. It could be seen in (4) that the 1-cells are not removed via the Pipeline.  <img src="../images/2d-arrangement-pipeline.jpg" alt="Pipeline visualization"/></p><blockquote><p><strong>Figure 1:</strong> Pipeline visualization over a sample structure.</p></blockquote><p>More examples could be find in the <code>test</code> and <code>examples</code> directory.</p><footer><hr/><a class="previous" href="../arrangement/"><span class="direction">Previous</span><span class="title">Arrangement module</span></a><a class="next" href="../mapper/"><span class="direction">Next</span><span class="title">Mapper</span></a></footer></article></body></html>
